;; Implementation of Huffman trees backed with assoc lists
;; Am trying to achieve good runtimes for all functions
(labels
    ;; Functions which define the tree structure we will use
    ((make-tree (entry weight left right) (list entry weight left right))
     (entry (tree) (car tree))
     (weight (tree) (cadr tree))
     (left-branch (tree) (caddr tree))
     (right-branch (tree) (cadddr tree))
     (leaf? (tree) (not (or (left-branch tree) (right-branch tree))))
     ;; Some basic Trie functions
     ;; I'm gonna abuse the "weight" thing to be the "is-terminal" accessor
     (new-trie () (make-tree nil nil nil nil))
     (insert-into-trie (payload code-seq trie)
       (cond ((null code-seq) (setf (car trie) payload) (setf (cadr trie) t))
             ((zerop (car code-seq))
              (unless (left-branch trie) (setf (caddr trie) (new-trie)))
              (insert-into-trie payload (cdr code-seq) (left-branch trie)))
             (t
              (unless (right-branch trie) (setf (cadddr trie) (new-trie)))
              (insert-into-trie payload (cdr code-seq) (right-branch trie))))
       trie)
     ;; The actual huffman code functions
     ;; Using an ordered set representation would have simplified this greatly :|
     (+min (s1 s2) (if (<= (weight s1) (weight s2)) s1 s2))
     (+max (s1 s2) (if (<= (weight s1) (weight s2)) s2 s1))
     (twomins (alist)
       (reduce (lambda (curr-result el)
                 (destructuring-bind (min almost-min) curr-result
                   (cond ((null min) (list el nil))
                         ((null almost-min) (list (+min min el) (+max min el)))
                         (t (let ((new-min (+min min el))
                                  (new-almost-min (+min almost-min (+max min el))))
                              (list new-min new-almost-min))))))
               alist :initial-value '(nil nil)))
     (htree-from-subtrees (subtrees)
       (if (null (cdr subtrees))
           (car subtrees)
           (destructuring-bind (min omin) (twomins subtrees)
             (htree-from-subtrees (cons
                                   (make-tree (gensym) (+ (weight min) (weight omin)) min omin)
                                   (remove-if (lambda (tnode) (or (equal (entry tnode)
                                                                         (entry min))
                                                                  (equal (entry tnode)
                                                                         (entry omin))))
                                              subtrees)))))))
  ;; This function is slow because we're using a stack, not a deque
  (defun codebook-from-htree (htree)
    (let (codebook stack)
      (labels ((rec (htree)
                 (if (leaf? htree)
                     (push (cons (entry htree) (reverse stack)) codebook)
                     (progn (push 0 stack) (rec (left-branch htree))
                            (setf stack (cdr stack))
                            (push 1 stack) (rec (right-branch htree))
                            (setf stack (cdr stack))))))
        (rec htree)
        codebook)))
  (defun htree-from-codebook (codebook)
    (reduce (lambda (letter-code trie)
              (insert-into-trie (car letter-code) (cdr letter-code) trie))
            codebook :initial-value (new-trie) :from-end t))
  (defun htree-for-pairs (pairs)
    (htree-from-subtrees (mapcar (lambda (p) (make-tree (car p) (cadr p) nil nil)) pairs)))
  (defun encode (message-seq codebook)
    (apply #'append (mapcar (lambda (char) (cdr (assoc char codebook))) message-seq)))
  (defun decode (code-seq codebook)
    (let ((htree (htree-from-codebook codebook))
          stack)
      (labels ((rec (code-seq trie)
                 (when (weight trie) (push (entry trie) stack) (setf trie htree))
                 (if (null code-seq)
                     (reverse stack)
                     (if (zerop (car code-seq))
                         (rec (cdr code-seq) (left-branch trie))
                         (rec (cdr code-seq) (right-branch trie))))))
        (rec code-seq htree)))))
