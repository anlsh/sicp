(defun same-symbol (x y) (eq x y))
(defun is-const (exp) (numberp exp))
(defun is-var (exp) (symbolp exp))

;; This is honestly incredibly ugly
;; The make-functions can probably be simplified using reduce
(defun is-sum (exp) (eq (car exp) '+))
(defun summand (exp) (cadr exp))
(defun summend (exp)
  (if (= (length exp) 3)
      (caddr exp)
      (cons '+ (cddr exp))))
(defun make-sum (summand summend &rest summends)
  (cond ((null summends)
         (cond ((equal 0 summand) summend)
               ((equal 0 summend) summand)
               (t (list '+ summand summend))))
        ((equal summand 0) (apply #'make-sum summend summends))
        (t (let ((end-sum (apply #'make-sum summend summends)))
             (if (equal end-sum 0)
                 summand
                 (append (list '+ summand) (if (listp end-sum)
                                               (if (equal (car end-sum) '+) (cdr end-sum) end-sum)
                                               (list end-sum))))))))

(defun is-prod (exp) (eq (car exp) '*))
(defun prodand (exp) (cadr exp))
(defun prodend (exp)
  (if (= (length exp) 3)
      (caddr exp)
      (cons '* (cddr exp))))
(defun make-prod (f1 f2 &rest frest)
  (cond ((null frest)
         (cond ((equal 1 f1) f2)
               ((equal 1 f2) f1)
               ((or (equal f1 0) (equal f2 0)) 0)
               (t (list '* f1 f2))))
        ((equal f1 1) (apply #'make-prod f2 frest))
        (t (let ((end-sum (apply #'make-prod f2 frest)))
             (cond ((equal end-sum 1) f1)
                   ((equal end-sum 0) 0)
                   (t (append (list '* f1) (if (listp end-sum)
                                               (if (equal (car end-sum) '*) (cdr end-sum) end-sum)
                                               (list end-sum)))))))))

(defun is-expt (exp) (eq (car exp) '**))
(defun base (exp) (cadr exp))
(defun expo (exp) (caddr exp))
(defun make-expt (base expo)
  (cond ((equal expo 0) 1)
        ((equal expo 1) base)
        (t (list '** base expo))))

(defun derive-exp (exp var)
  (cond ((is-const exp) 0)
        ((is-var exp) (if (same-symbol exp var) 1 0))
        ((is-sum exp) (make-sum (derive-exp (summand exp) var) (derive-exp (summend exp) var)))
        ((is-prod exp)
         (let ((f1 (prodand exp)) (f2 (prodend exp)))
           (make-sum (make-prod f1 (derive-exp f2 var)) (make-prod f2 (derive-exp f1 var)))))
        ((is-expt exp)
         (let ((base (base exp)) (expo (expo exp)))
           (make-prod expo (make-expt base (make-sum expo -1)))))))
